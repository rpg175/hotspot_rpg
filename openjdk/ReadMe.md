# jdk hotspot源码中文注释

## JVM启动流程源码分析

jvm的启动流程可以分为下面几步:

1. JVM 启动入口函数`java.base/share/native/launcher/main.c`的`JLI_Launch`函数。
   1. JVM运行环境的设置和检查
   2. 通过`CreateExecuteionEnvironment`函数查找`JAVA_DLL`动态库是否存在，能不能访问。并设置一些变量
   3. 加载动态库，将动态库中的一些函数链接至本地变量。
   4. 解释`options`和`args`参数。
   5. 新建线程初始化虚拟机
   6. 加载并执行主类

2. 具体的设计及推理验证过程。

3. SPI的示例
   1. 线程类加载器，我之前写斗地主发牌器用过，一般来说正常发牌的时候是随机发牌的。但是我们为了方便测试测试，写了可以按指定脚本发牌逻辑。为了区别测试环境和线上环境，我把发牌器打成了jar放到指定文件目录下面，利用线程类加载器就可以跑指定的jar的发牌算法，然后线上发布的时候把指定的jar给排除掉，就可以跑正常的发牌算法.....这个过程中没有写一句入侵的业务代码....就是利用线程类加载器的特性来做的.....如果自己实现classloader，不就需要在业务代码里面写一些额外的逻辑了么？
   2. 双亲委派及打破双亲委派：
      1. 关键看谁加载class
         1. 如果是boot加载class，则没有打破
         2. 如果是自定义加载，则打破了
## JVM的C++解释器工作原理

## JVM的模版解释器工作原理
1. 为每个字节码创建模板；
2. 利用模板为每个字节码生成对应的机器指令；
3. 将每个字节码生成的机器指令地址存储在派发表中；
4. 在每个字节码生成的机器指令末尾，插入自动跳转下条指令逻辑。

```
为什么模版解释器比C++解释器快？
1. c++解释器是代码生成的汇编代码（ISA指令集）
2. 模版解释器是hotspot内置实现的对应平台的汇编代码，手动实现的汇编代码（ISA指令集）

原因：
1.c++解释器自己生成的汇编代码，是平台无关的汇编指令，不可控和不规范
2.模版解释器生成的汇编代码，更可控，更精准
```

## 自动内存管理

### 自动内存管理

* Java内存区域与内存溢出异常
   * 运行时数据区域
      1. 程序计数器
      2. Java虚拟机栈
      3. 本地方法栈
      4. java堆
      5. 方法区
      6. 运行时常量池
      7. 直接内存
   * HotSpot虚拟机对象探秘
      1. 对象的创建
      2. 对象的内存布局
      3. 对象的访问定位

### 线程调度

## 并发原理
### 并发出现的原因
指令流水线
### Intel给出的解决方案
### Java的JUC原理

### 一段很火的代码
这段代码最近火的一塌糊涂。
总结一下就是让gc有条件执行，这个条件不仅仅是获取cpu那么简单。
如果只认识到让cpu给gc，只是那只能说境界还不够。这里面门道比较多。
1，在hotspot虚拟机里面，gc的必要条件是程序停留在安全点或者安全域，而sleep是native方法，被hotspot虚拟机认为处于安全域。
具体可参考hotspot源码注释。
2，hotspot虚拟机认为使用int来计数的循环体执行很快，所以当gc线程检测到需要stw时，发现是int型的循环体，就先放行，循环体执行完才考虑设立安全点。
而sleep0就是相当于在int计数的循环体中插入安全点。换句话说，这个地方不sleep0，把int改成long，也是可以达到相同效果。
