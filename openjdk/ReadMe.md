# jdk hotspot源码中文注释

## JVM启动流程源码分析

jvm的启动流程可以分为下面几步:

1. JVM 启动入口函数`java.base/share/native/launcher/main.c`的`JLI_Launch`函数。
   1. JVM运行环境的设置和检查
   2. 通过`CreateExecuteionEnvironment`函数查找`JAVA_DLL`动态库是否存在，能不能访问。并设置一些变量
   3. 加载动态库，将动态库中的一些函数链接至本地变量。
   4. 解释`options`和`args`参数。
   5. 新建线程初始化虚拟机
   6. 加载并执行主类

2. 具体的设计及推理验证过程。

3. SPI的示例
   1. 线程类加载器，我之前写斗地主发牌器用过，一般来说正常发牌的时候是随机发牌的。但是我们为了方便测试测试，写了可以按指定脚本发牌逻辑。为了区别测试环境和线上环境，我把发牌器打成了jar放到指定文件目录下面，利用线程类加载器就可以跑指定的jar的发牌算法，然后线上发布的时候把指定的jar给排除掉，就可以跑正常的发牌算法.....这个过程中没有写一句入侵的业务代码....就是利用线程类加载器的特性来做的.....如果自己实现classloader，不就需要在业务代码里面写一些额外的逻辑了么？

## JVM的C++解释器工作原理

## JVM的模版解释器工作原理
1. 为每个字节码创建模板；
2. 利用模板为每个字节码生成对应的机器指令；
3. 将每个字节码生成的机器指令地址存储在派发表中；
4. 在每个字节码生成的机器指令末尾，插入自动跳转下条指令逻辑。

```
为什么模版解释器比C++解释器快？
1. c++解释器是代码生成的汇编代码（ISA指令集）
2. 模版解释器是hotspot内置实现的对应平台的汇编代码，手动实现的汇编代码（ISA指令集）

原因：
1.c++解释器自己生成的汇编代码，是平台无关的汇编指令，不可控和不规范
2.模版解释器生成的汇编代码，更可控，更精准
```

## 自动内存管理

### 自动内存管理

* Java内存区域与内存溢出异常
   * 运行时数据区域
      1. 程序计数器
      2. Java虚拟机栈
      3. 本地方法栈
      4. java堆
      5. 方法区
      6. 运行时常量池
      7. 直接内存
   * HotSpot虚拟机对象探秘
      1. 对象的创建
      2. 对象的内存布局
      3. 对象的访问定位

